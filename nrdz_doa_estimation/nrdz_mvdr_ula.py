# This script uses the minimum variance distortionless response (MVDR) algorithm to estimate the direction of arrival (DOA)
# Read the data from file or use test data generated by script
# Perform an FFT first
# Calculate sample covariance matrix for each frequency channel
# Estimate power spectrum with MVDR solution
# This can only detect one signal at the same frequency channel

import os
import sys
import time
import math
import numpy as np
import matplotlib.pyplot as plt

# Size of real or imaginary data in file
#data_size = 20000000 # Large data size similar to real data
data_size = 2000 # Small data size for quick testing so you don't sit around waiting forever 
# Speed of light
c = 3e8

# File path
filepath = "/mnt/datab-netStorage-1G/sync/"
# Extension of files
extension = ".sc16"

def coordinate_calculation(sensor_idx, sensor1_lat, sensor2_lat, deltaLat, deltaLng):
    # List of sensors other than north
    sensors = ["rooftop", "gate", "chime", "west"]
    
    # Calculate distance between points
    a = np.sin(deltaLat/2)*np.sin(deltaLat/2) + np.cos(sensor2_lat)*np.cos(sensor1_lat)*np.sin(deltaLng/2)*np.sin(deltaLng/2)
    c = 2*np.arctan2(np.sqrt(a),np.sqrt(1-a))
    R = 6371e3 # Radius of the earth in meters
    d = R*c

    print("Distance between north and " + sensors[sensor_idx] + " = " + str(d) + " meters")

    # Calculate bearing
    y = np.sin(deltaLng)*np.cos(sensor1_lat)
    x = np.cos(sensor2_lat)*np.sin(sensor1_lat) - np.sin(sensor2_lat)*np.cos(sensor1_lat)*np.cos(deltaLng)
    theta = np.arctan2(y, x)
    bearing = theta*180/np.pi

    print("Bearing of north to " + sensors[sensor_idx] + " = " + str(bearing))

    # Calculate x and y coordinates between north and gate in meters
    x_m = d*np.sin(theta)
    y_m = d*np.cos(theta)
    
    r = np.zeros(2)
    r[0] = x_m
    r[1] = y_m
    
    return r

def north_rooftop_cartesian_estimates():
    # Sensor 5, North (Reference sensor)
    north_lat = 40.8216550*np.pi/180 #40.4902*np.pi/180
    north_lng = -121.4682424*np.pi/180 #121.2808*np.pi/180

    # Senor 2, Rooftop
    rooftop_lat = 40.8172*np.pi/180 #40.4932*np.pi/180
    rooftop_lng = -121.469*np.pi/180 #121.2812*np.pi/180

    # Change in latitude and longitude of north and rooftop
    deltaLat_nr = north_lat - rooftop_lat
    deltaLng_nr = north_lng - rooftop_lng

    sensor_idx = 0
    r_rooftop = coordinate_calculation(sensor_idx, north_lat, rooftop_lat, deltaLat_nr, deltaLng_nr)
    
    return r_rooftop 

def north_gate_cartesian_estimates():
    # Sensor 5, North (Reference sensor)
    north_lat = 40.8216550*np.pi/180 #40.4902*np.pi/180
    north_lng = -121.4682424*np.pi/180 #121.2808*np.pi/180

    # Senor 2, Gate
    gate_lat = 40.8257948*np.pi/180 #40.4932*np.pi/180
    gate_lng = -121.4702578*np.pi/180 #121.2812*np.pi/180

    # Change in latitude and longitude of north and gate
    deltaLat_ng = north_lat - gate_lat
    deltaLng_ng = north_lng - gate_lng

    sensor_idx = 1
    r_gate = coordinate_calculation(sensor_idx, north_lat, gate_lat, deltaLat_ng, deltaLng_ng)
    
    return r_gate    
    
def north_chime_cartesian_estimates():
    # Sensor 5, North (Reference sensor)
    north_lat = 40.8216550*np.pi/180 #40.4902*np.pi/180
    north_lng = -121.4682424*np.pi/180 #121.2808*np.pi/180

    # Sensor 3, Chime
    chime_lat = 40.8166504*np.pi/180 #40.4859*np.pi/180
    chime_lng = -121.4639321*np.pi/180 #121.2750*np.pi/180

    # Change in latitude and longitude of north and chime
    deltaLat_nc = north_lat - chime_lat
    deltaLng_nc = north_lng - chime_lng
    
    sensor_idx = 2
    r_chime = coordinate_calculation(sensor_idx, north_lat, chime_lat, deltaLat_nc, deltaLng_nc)
    
    return r_chime
    
def north_west_cartesian_estimates():
    # Sensor 5, North (Reference sensor)
    north_lat = 40.8216550*np.pi/180 #40.4902*np.pi/180
    north_lng = -121.4682424*np.pi/180 #121.2808*np.pi/180

    # Sensor 4, West
    west_lat = 40.8167476*np.pi/180 #40.4900*np.pi/180
    west_lng = -121.4720492*np.pi/180 #121.2819*np.pi/180
    
    # Change in latitude and longitude of west and gate
    deltaLat_nw = north_lat - west_lat
    deltaLng_nw = north_lng - west_lng

    sensor_idx = 3
    r_west = coordinate_calculation(sensor_idx, north_lat, west_lat, deltaLat_nw, deltaLng_nw)
    
    return r_west

# Generate synthetic data
def synthetic_data(freq, tbin, rx, ry, rz):
    x_comp = np.zeros([data_size]) + 1j*np.zeros([data_size]) # Complex data array
    w = 2*np.pi*freq # Angular frequency
    n_sources = 1 # Number of sources
    s = np.zeros([data_size, n_sources]) + 1j*np.zeros([data_size, n_sources]) # Signal amplitude
    src1_el = 45 # First source's elevation
    ang_spread = 80 # The angle spread between sources
    samp_el_offset = 0 # Change in elevation over time. Offsets signal position with a change in sample
     
    noise = np.random.normal(loc=0, scale=0.005, size=data_size) + 1j*np.random.normal(loc=0, scale=0.005, size=data_size)
    #noise = np.random.normal(loc=0, scale=1, size=data_size) + 1j*np.random.normal(loc=0, scale=1, size=data_size)
    #noise = np.zeros([data_size]) + 1j*np.zeros([data_size]) 
    srcs = np.zeros([data_size]) + 1j*np.zeros([data_size])
    prev_srcs = np.zeros([data_size]) + 1j*np.zeros([data_size])
    t = np.linspace(0,data_size*tbin,data_size)
    el = np.zeros([n_sources])
    for p in range(0, n_sources):
        el[p] = (src1_el + (ang_spread*p))*np.pi/180
        phase = (-1*w/c)*(\
        rx*np.sin(el[p])*np.cos(0)\
        + ry*np.sin(el[p])*np.sin(0)\
        + rz*np.cos(el[p]))
        
        s[:,p] = np.exp(1j*((w*t) + (phase%(2*np.pi))))
        srcs += s[:,p]
        
    x_comp = srcs + noise
    
    # Check if signals are linearly independent
    #is_linearly_independent = np.all(np.linalg.det(np.vstack((s[0,:],s[1,:])).T) != 0)
    #print("Are the signals linearly independent? ", is_linearly_independent)

    return x_comp

# Generate synthetic data and write to binary file to test the code
def write_synthetic_data(filename, freq, tbin, rx, ry, rz, n_ants):
    x_comp = np.zeros([n_ants, data_size]) + 1j*np.zeros([n_ants, data_size]) # Complex data array
    x = np.zeros([2*data_size]).astype(np.int16) # Interleaved data array (real - even, imag - odd)
    full_filename = [""]*n_ants
    file_count = 0 # Count number of files generated
    
    # Generate synthetic data
    for i in range(0, n_ants):
        full_filename[i] = filepath + filename + str(i) + extension
        if not os.path.exists(full_filename[i]):
            x_comp[i,:] = synthetic_data(freq, tbin, rx[i], ry[i], rz[i])
            
            print("max x_comp["+ str(i) + "] = " + str(np.max(np.abs(x_comp[i,:]))))
            file_count += 1
        else:
            print("Test file, " + full_filename[i] + " exists so don't need to synthesize data, create, and write to it again.")
        
    # Convert elements in array to 16 bit integers the same way as with live data acquisition
    if file_count > 0:
        # Determine the maximum absolute value of the real and imaginary arrays
        max_int16 = 32767
        max_abs_value = np.max(np.abs(x_comp))
        scaling_factor = max_int16/max_abs_value
        scaled_x_comp = scaling_factor*x_comp
        arr_r = np.array(scaled_x_comp.real)
        scaled_arr_r = (arr_r).astype(np.int16)
        arr_i = np.array(scaled_x_comp.imag)
        scaled_arr_i = (arr_i).astype(np.int16)
    else:
        print("No conversion to 16 bits needed since no file need to be written.")
    
    for i in range(0, n_ants):
        if not os.path.exists(full_filename[i]):
            # Interleave real and imaginary components in array
            x[0:(2*data_size):2] = scaled_arr_r[i,:]
            x[1:(2*data_size):2] = scaled_arr_i[i,:]
            
            # Write data to binary file
            print("Writing to file, " + full_filename[i])
            with open(full_filename[i], 'wb') as f:
                f.write(x.tobytes())
            f.close()
        else:
            print(full_filename[i] + " exists.")

# Read file or generate test data 
def complex_data_sc16(data_flag, freq, tbin, filename, rx, ry, rz):
    if data_flag == 0: # Use test data
        data_comp = synthetic_data(freq, rx, ry, rz)
    elif data_flag == 1: # Read binary file
        if os.path.exists(filename):
            with open(filename, 'rb') as f:
                contents_nrdz = np.fromfile(f, dtype=np.int16)
                contents_size = len(contents_nrdz)
                # Interleave inphase and quadrature
                data_re = contents_nrdz[0:contents_size:2]
                data_im = contents_nrdz[1:contents_size:2]
                data_comp = data_re + 1j*data_im
        else:
            print("File, " + filename + " does not exist. Try another file.")
            print("Exiting...")
            sys.exit()
            
        f.close()
        
    return data_comp
    
# Perform FFT and return 2D array with dimensions, NSAMPS X NPOINTS
def perform_FFT(complex_data, n_points):
    data_len = len(complex_data)
    n_samps = int(data_len/n_points)
    data_fft = np.zeros([n_samps, n_points]) + 1j*np.zeros([n_samps, n_points]) 
    # Perform N-point FFT on data with dimensions, NSAMPS x NPOINTS
    for i in range(0, n_samps):
        data_fft[i,:] = np.fft.fft(complex_data[(0+i*n_points):(n_points+i*n_points)])
    
    return data_fft 

# Estimate sample covariance
def estimate_sample_covariance(x, n_ants, n_samps, n_points, n_ints):
    n_windows = int(n_samps/n_ints)
    if n_points > 1:
        R_est = np.zeros([n_ants, n_ants, n_samps, n_points]) + 1j*np.zeros([n_ants, n_ants, n_samps, n_points])
        R_hat = np.zeros([n_ants, n_ants, n_windows, n_points]) + 1j*np.zeros([n_ants, n_ants, n_windows, n_points])
    # Estimate covariance
    #for a in range(0, n_ants):
    #    for b in range(0, n_ants):
    #        R_est[a,b,:,:] = (np.multiply(x[a,:,:], np.conjugate(x[b,:,:])))
            
        for f in range(0, n_points):
            for t in range(0, n_samps):
                x_H = np.transpose(np.conj(x[:,t,f]))
                R_est[:,:,t,f] = (np.outer(x[:,t,f], x_H))
            
        # Integrate over time samples
        for i in range(0, n_windows):
            R_hat[:,:,i,:] = (1/n_ints)*np.sum(R_est[:,:,(0 + i*n_ints):((n_ints + i*n_ints)),:], axis=2)
    elif n_points == 1:
        R_est = np.zeros([n_ants, n_ants, n_samps]) + 1j*np.zeros([n_ants, n_ants, n_samps])
        R_hat = np.zeros([n_ants, n_ants, n_windows]) + 1j*np.zeros([n_ants, n_ants, n_windows])
    # Estimate covariance
    #for a in range(0, n_ants):
    #    for b in range(0, n_ants):
    #        R_est[a,b,:,:] = (np.multiply(x[a,:,:], np.conjugate(x[b,:,:])))

        for t in range(0, n_samps):
            x_H = np.transpose(np.conj(x[:,t]))
            R_est[:,:,t] = (np.outer(x[:,t], x_H))
            
        # Integrate over time samples
        for i in range(0, n_windows):
            R_hat[:,:,i] = (1/n_ints)*np.sum(R_est[:,:,(0 + i*n_ints):((n_ints + i*n_ints))], axis=2)
        
    return R_hat
    
# Calculate array manifold vector to use in MVDR solution
def array_manifold_vector(elevation, azimuth, rx, ry, rz, f, n_ants):
    # Angular frequency
    w = 2*np.pi*f
    el = elevation*np.pi/180
    az = azimuth*np.pi/180
    
    a = np.zeros(n_ants) + 1j*np.zeros(n_ants)
    
    if n_ants == 1:
        for i in  range(0,n_ants):
            a[i] = np.exp((-1j*w/c)*(rx*np.sin(el)*np.cos(az) + ry*np.sin(el)*np.sin(az) + rz*np.cos(el)))
    else:
        for i in  range(0,n_ants):
            a[i] = np.exp((-1j*w/c)*(rx[i]*np.sin(el)*np.cos(az) + ry[i]*np.sin(el)*np.sin(az) + rz[i]*np.cos(el)))
    
    return a
     
def main():
    start_time = time.time()
    freq = 70e6
    wl = c/freq
    bl = wl/2
    samp_rate = 1.5e3
    tbin = 1/samp_rate # Time between samples
    full_band = 20e6 # Full bandwidth in Hz
    n_points = 100 # Number of points of FFT
    n_ants = 5 # Number of sensors/antennas
    if data_size == 20000000:
        n_ints = 100 # Number of time samples to integrate
    elif data_size == 2000:
        n_ints = 10 # Number of time samples to integrate
    else:
        n_ints = 1 # Number of time samples to integrate
    n_samps = int(data_size/n_points) # Number of time samples after FFT
    
    print("Calculating cartesian coordiantes...")
    # Get cartesian coordinates between sensors
    r_rooftop = north_rooftop_cartesian_estimates()
    r_gate = north_gate_cartesian_estimates()
    r_chime = north_chime_cartesian_estimates()
    r_west = north_west_cartesian_estimates()
    coordinate_scaling = 1000
    # ULA - the distance between antennas needs to be less than or equal to lambda/2 to avoid grating lobes
    rx = np.zeros(n_ants)
    rx[0] = 0
    rx[1] = bl#10e3 #r_rooftop[0]/coordinate_scaling
    rx[2] = 2*rx[1]#20e3 #r_gate[0]/coordinate_scaling
    rx[3] = 3*rx[1]#30e3 #r_chime[0]/coordinate_scaling
    rx[4] = 4*rx[1]#40e3 #r_west[0]/coordinate_scaling
    ry = np.zeros(n_ants)
    ry[0] = 0
    ry[1] = 0 #r_rooftop[1]/coordinate_scaling
    ry[2] = 0 #r_gate[1]/coordinate_scaling
    ry[3] = 0 #r_chime[1]/coordinate_scaling
    ry[4] = 0 #r_west[1]/coordinate_scaling
    rz = np.zeros(n_ants)
    
    print("Rooftop X and Y coordinates respectively: " + str(rx[1]) + " m and " + str(ry[1]) + " m")
    print("Gate X and Y coordinates respectively: " + str(rx[2]) + " m and " + str(ry[2]) + " m")
    print("Chime X and Y coordinates respectively: " + str(rx[3]) + " m and " + str(ry[3]) + " m")
    print("West X and Y coordinates respectively: " + str(rx[4]) + " m and " + str(ry[4]) + " m")
    
    data_flag = 0 # If set to 0, the script generates it's own data, and if set to 1, it reads a file
    sim_data_write = 1 # If set to 1, the script synthesizes data and writes it to a binary file to be read, and if set to 0, the simulated data is not written to and read from binary files
    
    filename = "sensor_test_"
    full_filename = [""]*n_ants
    
    # Synthesize test data if flag is set to 1
    if sim_data_write == 1:
        print("Writing data to files...")
        data_flag = 1
        write_synthetic_data(filename, freq, tbin, rx, ry, rz, n_ants)
    else:
        print("Simulated data has not been written to any files. It has just been generated and processed by the script.")
    
    print("Reading data for processing...")
    if n_points > 1:
        X_agg = np.zeros([n_ants, n_samps, n_points]) + 1j*np.zeros([n_ants, n_samps, n_points])
    elif n_points == 1:
        X_agg = np.zeros([n_ants, n_samps]) + 1j*np.zeros([n_ants, n_samps])
        
    # Read/generate data, perform FFT and aggregate sensor data 
    for i in range(0, n_ants):
        full_filename[i] = filepath + filename + str(i) + extension
        # Read or generate complex data
        x = complex_data_sc16(data_flag, freq, tbin, full_filename[i], rx[i], ry[i], rz[i])
        if n_points > 1:
            # Perform FFT
            Xfft = perform_FFT(x, n_points)
            # Aggregate sensor data
            X_agg[i,:,:] = Xfft
        elif n_points == 1:
            # Aggregate sensor data
            X_agg[i,:] = x
            
    #plt.figure()
    #plt.imshow(abs(X_agg[0,:,:]), extent=[0, n_points, 0, n_samps], aspect='auto', interpolation='none')
    #plt.title("Waterfall plot of amplitudes after FFT")
    #plt.ylabel("Time samples")
    #plt.xlabel("N-points")
    #plt.show()
    
    #plt.figure()
    #plt.imshow(abs(X_agg[1,:,:]), extent=[0, n_points, 0, n_samps], aspect='auto', interpolation='none')
    #plt.title("Waterfall plot of amplitudes after FFT")
    #plt.ylabel("Time samples")
    #plt.xlabel("N-points")
    #plt.show()
    
    #plt.figure()
    #plt.imshow(abs(X_agg[2,:,:]), extent=[0, n_points, 0, n_samps], aspect='auto', interpolation='none')
    #plt.title("Waterfall plot of amplitudes after FFT")
    #plt.ylabel("Time samples")
    #plt.xlabel("N-points")
    #plt.show()
    
    #plt.figure()
    #plt.imshow(abs(X_agg[3,:,:]), extent=[0, n_points, 0, n_samps], aspect='auto', interpolation='none')
    #plt.title("Waterfall plot of amplitudes after FFT")
    #plt.ylabel("Time samples")
    #plt.xlabel("N-points")
    #plt.show()
    
    #plt.figure()
    #plt.imshow(abs(X_agg[4,:,:]), extent=[0, n_points, 0, n_samps], aspect='auto', interpolation='none')
    #plt.title("Waterfall plot of amplitudes after FFT")
    #plt.ylabel("Time samples")
    #plt.xlabel("N-points")
    #plt.show()
    
    print("Estimating sample covariance matrix...")
    # Estimate sample covariance
    R_hat = estimate_sample_covariance(X_agg, n_ants, n_samps, n_points, n_ints)
    
    # Estimate power spectrum over elevation and azimuth
    deg_range = 180
    R_x = np.zeros([n_ants, n_ants]) + 1j*np.zeros([n_ants, n_ants])
    chan_idx = 50
    coarse_chan = full_band/n_points
    if n_points > 1:
        R_x = R_hat[:,:,0,chan_idx]
    elif n_points == 1:
        chan_idx = 0
        R_x = R_hat[:,:,0]
        
    f = freq + (chan_idx-n_points/2)*coarse_chan
    print(R_x)
    P = np.zeros([deg_range,deg_range])
    
    print("center_frequency = " + str(freq) + " f = " + str(f))
    
    print("Estimating power spectrum...")
    for el in range(0,deg_range):
        for az in range(0,deg_range):
            a = array_manifold_vector(el, 0, rx, ry, rz, f, n_ants)
            a_H = np.transpose(np.conjugate(a))
            #P_den = abs(a_H.dot(np.linalg.inv(R_x)).dot(a))
            #P_den = abs(a_H.dot(np.linalg.inv(np.eye(n_ants,n_ants))).dot(a))
            P_den = abs(np.dot(np.dot(a_H,np.linalg.inv(R_x)), a))
            P[el,az] = 1/P_den
            
    print("Plotting power over elevation and azimuth...")
    # Plot map of power estimate at a particular coarse channel
    # Note - origin="lower" ensures that the origin is the lower left corner
    plt.figure()
    plt.imshow(P[0:int(deg_range/2),0:int(deg_range/2)], origin="lower", extent=[0, int(deg_range/2), 0, int(deg_range/2)], aspect='auto', interpolation='none')
    plt.title("Power spectrum of elevation and azimuth")
    plt.ylabel("Elevation")
    plt.xlabel("Azimuth")
    plt.show()
    
    # Plot map of power estimate at a particular coarse channel
    plt.figure()
    plt.plot(P[0:int(deg_range/2),0])
    plt.title("Power spectrum over elevation")
    plt.ylabel("Power (arb. units)")
    plt.xlabel("Elevation")
    plt.show()

    end_time = time.time()
    execution_time = end_time-start_time
    print("Execution time = " + str(execution_time) + " seconds")
    print("Done!")

if __name__ == "__main__":
    main()





